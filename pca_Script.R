install.packages("AppliedPredictiveModeling")
install.packages("dplyr")
install.packages("tidyr")
install.packages("Correlplot")
install.packages("lattice")
install.packages("caret")
library(lattice)
library(AppliedPredictiveModeling)
library(dplyr)
library(tidyr)
library(ggplot2)
library(corrplot)
library(caret)
library(e1071)
cwd <- getwd()
file.name <- "Kaggle-data-FINAL.csv"
paste(cwd, file.name ,sep="/")
kdatafinal <- read.csv(paste(cwd, file.name ,sep="/"))
# I am removing md5
malwaredf <- Kdatafinal[, -2]
malwaredf
str(malwaredf)
# Find out the length of the data frame
print(length(malwaredf))
# PCA analysis
#find out the mean of cor(malwaredf)
#1. Check PCA eligibility. After running the mean, I got 0.0423 as result which
#is high;therefore it is eligible for PCA
mean(cor(malwaredf)) # mean checks for the avg correlaion between the variables.
#2. Principal Component Analysis
#malwarePCA = princomp(malwaredf)
#It shows that the correlation between variables and the loading creation should equal                to the variables
#malwarePCA$loadings

#Create an object (PCmalware) to check if variables are dependent or not.If they are
#independent the correlation among the components must be zero or must be nearly zero.
#pcmalware = malwarePCA$scores

#View(pcmalware)
#summary(pcmalware)
#cor(pcmalware)
#Running skeweness to all the dataset (malwaredf)
skewValues <- apply(malwaredf,2,skewness)
library(caret)
#Running the PCA for the entire final data set
pcaM <- prcomp(malwaredf, center=TRUE, scale. = TRUE )
summary(pcaM)
#Running the PCA for the whole set minus the id column, so c(2:56).
#I can tell that there is 5 elements and its size is 95.2 MB, 2M smaller than the pcaM.
pcaM1<-prcomp(malwaredf [c(2:56)], center=TRUE, scale. = TRUE)
summary(pcaM1)
#Calculate the cumulative percentage of variance which each component accounts for.The PCA object for
#the Malwaredataset is pcaM1 (does not contain the ID column).
percentVarMalware <- pcaM1$sd^2/sum(pcaM1$sd^2)*100 
percentVarMalware[2:56]
plot(percentVarMalware, xlab="Components", ylab="Percentage of Total Variance", type="l", main="Scree Plot of PCA Analysis")
#The another sub-object called rotation stores the variable loadings, where  rows correspond to 
#predictor variables and columns are associated with the  components.
head(pcaM) # it brings up $x which has the PCs
head(pcaM1$rotation[, 1:5])
library(corrplot)

#Running correlation for the predictors
corrMalwaredf <- cor(malwaredf)
dim(corrMalwaredf)
#Visualize the correlation structure of the data. A heatmap cor was created by Matt instead of this one. 
corrplot(corrMalwaredf, order="hclust")
# filtering hig correlations, cutoff = 0.85
highCorr <- findCorrelation(corrMalwaredf, cutoff = .85)
length(highCorr)
head(highCorr)
filteredMalwaredf <- malwaredf[, -highCorr]#Filtering the highcorr variables, the data set gets 
#down to 48 variables.

# I will be using factoextra package to create a ggplot2-based for visualization
install.packages("factoextra")
library(factoextra)
library("FactoMineR")
pcaM <- prcomp(malwaredf, scale = TRUE)
print(pcaM)
#the eigenvalues measure the amount of variation retained by each principal component. 
#Eigenvalues are large for the first PCs and small for the subsequent PCs. That is, 
#the first PCs corresponds to the directions with the maximum amount of variation in the data set.
# Get Eigenvalues
eig.val <- get_eigenvalue(pcaM)
eig.val
get_eig(pcaM)
# Eigenvalues
eig.val1 <- get_eigenvalue(pcaM1)
eig.val1
#Extract eigenvalues/variances
get_eig(pcaM1)
#Visualize eigenvalues (scree plot). 
# The scree plot can be produced using the function fviz_eig() or fviz_screeplot() [factoextra package].
fviz_screeplot(pcaM, addlabels = TRUE, ylim = c(0, 50))
fviz_screeplot(pcaM1, addlabels = TRUE, ylim = c(0, 50))

fviz_eig(pcaM)
fviz_eig(pcaM1)
print(pcaM1)
# Extract the results for variables
varpca <- get_pca_var(pcaM1)
varpca
# Coordinates of variables
head(varpca$coord)
# Graph of variables: default plot
fviz_pca_var(pcaM1, col.var = "purple")

#It's possible to control variable colors using their contributions ("contrib") to the principal axes:
fviz_pca_var(pcaM1, col.var="contrib",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE # Avoid text overlapping
)
# Contributions of variables to PC1 for the top 5 variables
fviz_contrib(pcaM1, choice = "var", axes = 1, top = 5)
fviz_contrib(pcaM1, choice = "var", axes = 1:2, top = 5)
# Contributions of variables to PC1
fviz_contrib(pcaM1, choice = "var", axes = 1, top = 5)
# Extract the results for individuals
indpca <- get_pca_ind(pcaM1)
indpca
head(indpca$coord,10)
fviz_pca_ind(pcaM1)
#I cannot display it, it keep freezing Rstudio.
#fviz_pca_ind(pcaM1, col.ind = "cos2", 
 #            gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
            # repel = TRUE # Avoid text overlapping (slow if many points)
#)
# Biplot of individuals and variables
#fviz_pca_biplot(pcaM1, repel = TRUE) # It freezes Rstudio
#Visualize the cos2
head(varpca$cos2, 4)
corrplot(varpca$cos2, is.corr=FALSE)
# Color by cos2 values: quality on the factor map. The highest cos2 variable is 0.6.
fviz_pca_var(pcaM1, col.var = "cos2",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), 
             repel = TRUE # Avoid text overlapping
)
# Contributions of variables to PC1. The red dashed line on the graph above indicates the expected average contribution. 

fviz_contrib(pcaM1, choice = "var", axes = 1, top = 10)
# Contributions of variables to PC2
fviz_contrib(pcaM1, choice = "var", axes = 2, top = 10)
#The total contribution to PC1 and PC2 is obtained with the following R code:
fviz_contrib(pcaM1, choice = "var", axes = 1:2, top = 10)

# Create a grouping variable using kmeans
# Create 3 groups of variables (centers = 3)
set.seed(568)
res.km <- kmeans(varpca$coord, centers = 3, nstart = 25)
grp <- as.factor(res.km$cluster)
# Color variables by groups
fviz_pca_var(pcaM1, col.var = grp, 
             palette = c("#0073C2FF", "purple", "#868686FF"),
             legend.title = "Cluster")


# Adding Courtney's code
cwd <- getwd()
file.name <- "Kaggle-data-FINAL.csv"
paste(cwd, file.name ,sep="/")
FINALdata <- read.csv(paste(cwd, file.name ,sep="/"))
#create PCA without ID and non-numeric column or the predictor
FINALshortPR <- prcomp(FINALdata[c(3:56)], center = TRUE, scale = TRUE)

# Summary
summary(FINALshortPR)


#set plot
par(mfrow=c(1,1))

#regular scree plot
percentVariancePCA = FINALshortPR$sd^2/sum(FINALshortPR$sd^2)*100
plot(percentVariancePCA, xlab="Components", ylab="Percentage of Total Variance", type="l", main="Scree Plot of PCA Analysis")

#set plot
par(mfrow=c(1,2))

#see if we can remove where eigenvalue is less than 1
screeplot(FINALshortPR, type = "l", npcs = 40, main = "Screeplot of the first 40 PCs")
abline(h = 1, col = "red", lty=5)
legend("topright", legend=c("Eigenvalue=1"),
       col=c("red"), lty=5, cex=0.6)

cumpro <- cumsum(FINALshortPR$sdev^2 / sum(FINALshortPR$sdev^2))
plot(cumpro[0:40], xlab = "PC #", ylab = "Amount of explained variance", main = "Cumulative variance plot")
abline(v = 20, col="blue", lty=5)
abline(h=0.73456, col="blue", lty=5)
legend("topleft", legend=c("Cut-off @ PC20"),
       col=c("blue"), lty=5, cex=0.6)

#set plot
par(mfrow=c(1,1))

#we only account for 12% of variance with first 2 principal components
plot(FINALshortPR$x[,1], FINALshortPR$x[,2], xlab="PC1 (6.502%)", ylab = "PC2 (6.325%)", main=" PC1 / PC2 - plot")


install.packages("factoextra")
library("factoextra")
fviz_pca_ind(FINALshortPR, geom.ind = "point", pointshape = 21, 
             pointsize = 2, 
             fill.ind = factor(FINALdata$legitimate), 
             col.ind = "black", 
             palette = "jco", 
             addEllipses = TRUE,
             label = "var",
             col.var = "black",
             repel = TRUE,
             legend.title = "Legitimate") +
  ggtitle("2D PCA-plot") +
  theme(plot.title = element_text(hjust = 0.5))
fviz_pca_ind

